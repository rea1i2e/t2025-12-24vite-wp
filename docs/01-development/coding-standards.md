# コーディング規約

このドキュメントでは、プロジェクトで守るべきコーディング規約を説明します。

## HTML

### セマンティックHTML

#### セクションの基本構造

各セクションの基本構造は以下のように統一する：

```html
<section class="p-ページ名-セクション名 l-ページ名-セクション名" id="ページ名-セクション名">
  <div class="p-ページ名-セクション名__inner l-inner">
    <div class="p-ページ名-セクション名__heading">
      <h2 class="c-heading">見出し</h2>
    </div>
    <div class="p-ページ名-セクション名__content">
      <!-- コンテンツ -->
    </div>
  </div>
</section>
```

- `section`タグに`l-ページ名-セクション名`クラスと`id="ページ名-セクション名"`を付与する
- 見出し部分は`p-ページ名-セクション名__heading`で囲む
- コンテンツ部分は`p-ページ名-セクション名__content`で囲む
- ブロック名は`p-ページ名-セクション名`の形式で統一する
- HTMLの構造変更に合わせて、SCSSファイルも修正する（クラス名の変更、`__content`のスタイル追加など）
- クラス名の重複を避ける（例: セクション全体のコンテンツ用のクラスと、タブの個別コンテンツ用のクラスが同じ名前にならないようにする）

#### `em`タグの使い方（テキストに限定）

- 視覚的に強調されているテキスト部分に`em`タグを使用する
- 色を変えて視覚的に強調しているテキスト部分は`em`で囲む
- サイズが周囲よりも大きくなっているテキスト部分は`em`で囲む
- 他のテキストと同じで視覚的に強調されていない部分には`em`を使わない

### クラス名の付け方

- レスポンシブ対応を考慮し、`left`/`right`のような位置依存のクラス名を使わない
- スマホでは左ではないので`left`という名前をつけない
- スマホでは右ではないので`right`という名前をつけない

### 画像実装

#### 基本ルール

- 装飾的な画像は`background-image`で実装する
- `<img>`タグではなくCSSの`background-image`を使用する場合は、コメントで意図を明確にする
- 複雑なレイアウトは、無理にHTMLにせず後で画像を埋め込む

#### `<img>`タグのクラス付与

- `<img>`タグにはクラスを付与しない。スタイルが必要な場合は、親要素のクラス経由で`img`セレクタを使用する（例: `.p-top-features__button-icon img`）
  - 理由: `img`タグに直接クラスを付与するのではなく、親要素のクラス経由でスタイルを適用することで、HTMLの構造がシンプルになり、保守性が向上する
  - 例外: `.u-no-image`クラスだけは`img`タグに付与してもよい

#### 画像のパス命名規則

- 画像のパスは`ページ名/セクション名_画像名`の形式で指定する（例: `top/benefit_chart-donut.png`、`top/benefit_illustration-person.png`）
  - 理由: ページ名とセクション名を明確にすることで、画像の配置場所が分かりやすくなり、保守性が向上する。また、同じセクション内の画像をグループ化できる
- アイコンのようにページやセクションをまたがり共通で使う可能性の高いものは`common/`ディレクトリに入れ、ページやセクションに依存しない名前にする（例: `common/icon-arrow-right.svg`、`common/icon-check.svg`、`common/icon-document.svg`）
  - 理由: 共通アイコンを`common/`に配置することで、複数のページやセクションで再利用でき、保守性が向上する。また、ページやセクションに依存しない名前にすることで、どの場所でも使える汎用的なリソースであることが明確になる

#### `figure`タグの使用

- コンテンツ画像は`figure`タグで囲む（例: サムネイル画像、記事のメイン画像、製品・サービスの説明画像、認証画像・証明書画像、チャート・グラフなどの図表）
  - 理由: HTML5のセマンティック要素として適切で、画像がコンテンツの一部であることを明確にできる。スクリーンリーダーなどの支援技術での解釈が向上し、将来的に`<figcaption>`を追加する拡張性も確保できる

**例外：**

1. アイコン（装飾的要素）は`div`を使用する（例: 矢印アイコン、チェックマーク、その他のUI装飾アイコン）
   - 理由: 装飾的で意味的なコンテンツではないため

2. ロゴは`div`を使用する（例: サイトロゴ、企業ロゴ）
   - 理由: ブランディング要素で、図表ではないため

3. ボタン内のアイコンは`div`を使用する（例: `c-button`コンポーネント内のアイコン）
   - 理由: UI要素の一部で、独立したコンテンツではないため

4. 背景装飾画像は`background-image`で実装する（HTML構造に含まれない）

5. インラインアイコン（テキストと一緒に配置される小さなアイコン）は`div`を使用する（例: リスト項目の前のアイコン、リンク内の小さな矢印）
   - 理由: テキストの装飾要素で、独立したコンテンツではないため

6. リスト項目内のロゴ・アイコンは`div`を使用する（例: リスト項目の一部として配置されるロゴやアイコン）
   - 理由: リスト項目の一部で、独立した図表ではないため

**判断基準：** 画像が独立したコンテンツで、図表・図解として機能する場合は`figure`を使用し、装飾的要素やUI要素の一部の場合は`div`を使用する

## PHP

### 関数名

- **プレフィックス**: テーマ内で定義するPHP関数には必ず `ty_` プレフィックスを付与してください
  - 理由: WordPressやプラグインの関数名との衝突を避けるため
  - 例: `ty_theme_image_url()`, `ty_register_post_type_works()`

### function_exists の使用ルール

- **プラグイン関数のチェック**: プラグインで定義されている関数を使うときのみ `function_exists` を使用してください
- **子テーマでの上書きを想定しない**: 子テーマを想定しないため、関数定義の重複防止のための `function_exists` は不要です
- **同一テーマ内の関数への依存**: 同じテーマ内の関数を参照する場合、`function_exists` チェックは不要です（ファイル読み込み順序で解決）

### ファイル読み込み順序

- **`functions.php` の `$ordered`**: 依存関係があるファイルのみ `$ordered` 配列に追加することを推奨します
  - 通常は空でOKですが、トップレベルで別ファイルの関数/定数を参照する場合は順序指定が必要です

### コーディングスタイル

- **型宣言**: PHP関数には型宣言を付与することを推奨します（`declare(strict_types=1);` を使用）
- **コメント**: 関数の目的や引数の説明をコメントで記載することを推奨します

### 基本記述方法

- 配列は`array()`ではなく`[]`を使用する
- データ取得とHTMLの記述は可能な限り分ける
- PHPやHTMLを書く際に、コンテンツ部分は自動補完しない
- HTMLタグ内のテキストコンテンツを勝手に作らない
- 同じ構造のHTMLを繰り返し書くのではなく、配列にまとめてループで処理する
- 関連する複数の配列（例: タブボタン用の配列とタブコンテンツ用の配列）は、1つの配列に統合して管理する

### 連番の自動採番

- 連番は配列に手動で設定せず、`foreach`ループのインデックスを使って自動採番する（例: `foreach ($items as $index => $item)`で`$index + 1`を使用し、`sprintf('%02d', $index + 1)`で2桁のゼロ埋め番号を生成する）
  - 理由: 配列の順序に応じて自動で番号が付与されるため、ステップの追加・削除・並び替えが容易になり、保守性が向上する。手動で番号を管理する必要がなくなり、ミスを防げる

### WordPress固有のルール

#### サブクエリの条件指定

- サブクエリ（`WP_Query`、`get_posts()`など）の条件指定では、デフォルト値を明示的に指定しない（例: `orderby => 'date'`、`order => 'DESC'`は削除する）
  - 理由: WordPressのデフォルト値（`orderby => 'date'`、`order => 'DESC'`など）を明示的に指定すると、Post Types Orderなどのプラグインが`pre_get_posts`で変更したカスタム順序が反映されなくなる。デフォルト値を指定しないことで、プラグインの順序設定を尊重でき、管理画面で順序を変更できる柔軟性が確保される。また、WordPressのバージョンアップでデフォルト値が変更された場合でも、コードを修正する必要がなくなる

## CSS/Sass

### 基本記述方法

- `@include mq()`と`@media (any-hover: hover)`を除いて入れ子を使わずに書く
- クラス名をフラットに記述する

### 入れ子（ネスト）の使い方

基本的にフラットな構造を維持します。

- **BEMのクラス名は入れ子にしない**: `.p-component__element` は全てトップレベルで記述
- **子要素（タグ名）もフラットに記述**: `.p-component__element img` のようにスペース区切りで記述（入れ子にしない）
- **メディアクエリは入れ子で記述**: `@include mq() { ... }` は入れ子で使用
- **複数のセレクタはカンマで区切る**: `.element1, .element2 { ... }` のようにフラットに記述
- **複雑なセレクタもフラットに記述**: `.parent:has(.child) .target` のようにスペース区切りで記述
- 例（正）: 
  ```scss
  .p-single__thumbnail {
    margin-block-start: rem(20);
    @include mq() {
      margin-block-start: rem(30);
    }
  }
  .p-single__thumbnail img {
    width: 100%;
  }
  ```
- 例（誤）:
  ```scss
  .p-single__thumbnail {
    margin-block-start: rem(20);
    img {
      width: 100%;
    }
  }
  ```

### 論理プロパティ

- `margin`と`padding`を指定する際は論理プロパティを使用する（例: `margin-block-start`、`padding-inline`）
  - 理由: 書字方向（`writing-mode`）やテキスト方向（`direction`）が異なる場合でも、自動的に適切な方向に適用されるため、コードがスッキリし保守性が向上する。RTL対応や縦書き対応が必要になった際に、追加のスタイルを書く必要がなくなる

#### `margin-block-start`の使用

原則として `margin-block-start` のみを使用します。

- `margin-block-end` や `margin-block` は使用しない
- `margin-inline-start: 0;` はリセットCSSで既に指定されているため、明示的に書く必要はない
- 要素間の間隔は次の要素の `margin-block-start` で制御する
- 要素間に均等な余白をつける場合は隣接セレクタを使用する（例: `.p-top-benefits__desc + .p-top-benefits__desc { margin-block-start: 1rem; }`）
  - 隣接セレクタを使うことで、最初の要素の特別扱いが不要になり、シンプルで読みやすいコードになる。具体的なクラス名を使うことで、詳細度を適切に保ち、意図しない要素への適用を防ぐ
- 個別の要素に異なる余白を設定する必要がある場合は、要素単位で`margin-block-start`を指定する
- 例: `.element { margin-block-start: rem(20); }`

### コンポーネントの外側余白

コンポーネント自体には外側の余白（margin）をつけません。

- コンポーネントは再利用可能な部品のため、外側の余白は親要素で制御する
- 使用する側で親要素を追加し、そこに余白をつける
- 例:
  ```scss
  // コンポーネント（components-demo/_p-post-nav.scss）
  .p-post-nav {
    display: flex;
    // marginはつけない
  }
  
  // 使用する側（components/_p-single.scss）
  .p-single__post-nav {
    margin-block-start: rem(60);
    @include mq() {
      margin-block-start: rem(80);
    }
  }
  ```

### 値の指定

#### 1pxの指定

- 1pxを指定する際は`rem(1)`ではなく`1px`を直接指定する（例: `border: 1px solid`、`outline: 1px solid`、擬似要素の`height: 1px`など）
  - 理由: `rem(1)`はブラウザの丸め処理やフォントサイズの影響で、計算結果が1px未満になることがあり、レンダリングされない場合がある。1pxは常に正確に1pxであるべき値であり、`1px`を直接指定することで、ブラウザや環境に依存せず確実に表示される。ボーダー、アウトライン、擬似要素で細い線を作る場合など、すべてに適用される

#### `font-size`の指定

- `font-size`を指定する際は`rem()`ではなく`maxrem()`を使用する（例: `font-size: maxrem(14)`）
  - 理由: `maxrem()`はpx値をremに変換しつつ、最小値10pxを保証する関数。これにより、ブラウザのフォントサイズ設定が極端に小さい場合でも、テキストが読みやすさを保つ最小サイズを確保できる。アクセシビリティとユーザビリティの向上に寄与する

#### `letter-spacing`の指定

- `letter-spacing`を指定する際は、Figmaのデザインデータから取得した`font-size`と`letter-spacing`の値を使用して`calc()`で計算する（例: `font-size: rem(18)`、`letter-spacing: 0.9px`の場合、`letter-spacing: calc(0.9em / 18)`）
  - 理由: Figmaのデザインデータでは`letter-spacing`が`px`単位で指定されているが、CSSでは`em`単位を使用することで、`font-size`に応じて自動的に調整される。`calc(letter-spacing値em / font-size値)`という形で計算することで、Figmaのデザインを正確に再現しつつ、`font-size`が変更されても比率が維持される

### プロパティの指定順

CSSプロパティの指定順は、メディアクエリの有無を優先し、その中でカテゴリ別の順序で記述する：

- メディアクエリなしのスタイル（基本スタイル）を先に記述し、メディアクエリありのスタイル（`@include mq()`）を後に記述する
- メディアクエリ内でも、プロパティのカテゴリ順を維持する
- カテゴリ別の順序:
  1. レイアウト関連: `display`、`position`、`z-index`、`flex-direction`、`align-items`、`gap`、`margin`など
  2. サイズ・スペーシング: `width`、`height`、`min-height`、`max-width`、`padding`など
  3. 見た目（背景・ボーダー）: `background-color`、`border`、`border-radius`、`box-shadow`、`filter`など
  4. テキスト・フォント: `font-size`、`font-weight`、`color`、`text-align`、`line-height`など
  5. その他: `cursor`、`transition`、`opacity`など
- 理由: メディアクエリの有無を優先することで、モバイルファーストのアプローチが明確になり、レスポンシブデザインの意図が理解しやすくなる。基本スタイルとブレークポイントでの変更が分離されるため、保守性が向上する。メディアクエリ内でもカテゴリ順を維持することで、コードの一貫性が保たれる

### レイアウトとサイズ

#### `height`の使用

- `height`と`padding`の両方を指定する必要はない。`padding`だけで十分な場合は`height`を削除する
  - 理由: `height`を固定値で指定すると、コンテンツが増えた場合に問題が発生する可能性がある。`padding`だけで高さを制御することで、コンテンツに応じて柔軟に対応できる

**`height`を固定値で指定することの弊害：**

- コンテンツがはみ出す: 固定の`height`を指定すると、コンテンツがその高さを超えた場合に表示が崩れる
- レスポンシブ対応が困難: フォントサイズやテキスト量が変わる環境で、固定の`height`は適応しにくい
- 多言語対応の問題: 言語によってテキストの長さが変わる場合、固定の`height`では対応できない
- アクセシビリティの問題: ユーザーがブラウザのフォントサイズを大きくした場合、固定の`height`ではテキストが切れる可能性がある
- メンテナンス性の低下: コンテンツが変更されるたびに`height`を調整する必要があり、保守コストが上がる

**解決策：** `min-height`を使用する、`padding`のみで制御する、`flexbox`や`grid`を活用する

#### Flexboxでの高さ揃え

- Flexboxで横並びの要素の高さを揃える際は、`align-items: center`と固定の`min-height`の組み合わせを避け、`align-items: stretch`と`height: 100%`を使用する
  - 理由: `align-items: center`を使用すると、子要素の高さは内容に応じて決まり、左右の要素の高さが揃わない。固定の`min-height`を指定すると、コンテンツ量に応じた柔軟な対応ができず、メンテナンス性が低下する
  - 解決策: 親要素に`align-items: stretch`（デフォルト値）を明示し、子要素に`height: 100%`を指定することで、左右の要素の高さが自動的に揃い、コンテンツ量に応じて柔軟に対応できる
  - 適用例: 親要素が`display: flex`、`flex-direction: row`の場合、`align-items: stretch`を指定（または省略）し、左右の子要素それぞれの内部要素（例: `.p-top-benefits__chart-wrapper`と`.p-top-benefits__panel`）に`height: 100%`を指定する

### 影の指定

- 角丸がある要素に影を付ける場合は、`box-shadow`ではなく`filter: drop-shadow()`を使用する
  - 理由: `drop-shadow()`は要素の実際の形状（角丸や透明部分）に沿って影を描画するため、`box-shadow`よりも自然な見た目になる。特に角丸が大きい場合や、複雑な形状の要素では、`drop-shadow()`の方が適切に影が描画される

### カスタムプロパティ

- 色の値（例: `#0c203b`）はカスタムプロパティとして定義する
- カスタムプロパティは`src/assets/sass/base/_root.scss`の`:root`に記載する
- 使用箇所では`var(--カスタムプロパティ名)`を使用する
- カスタムプロパティの名前は、ブロック（コンポーネント）由来の名前ではなく、汎用的な名前にする（例: `--border-top-footer`ではなく`--border-white-opacity`、`--box-shadow-features`ではなく`--box-shadow-soft`）
  - 理由: 汎用的な名前にすることで、他のコンポーネントでも再利用でき、保守性が向上する。また、`border-top`だけでなく`border-bottom`でも使える可能性を考慮する
- カスタムプロパティには、色だけではなく値全体を登録する（例: `border-color`だけではなく`border-top: 1px solid rgba(255, 255, 255, 0.2)`の全体、`box-shadow`の値全体）
  - 理由: 値全体をカスタムプロパティにすることで、一箇所で管理でき、変更が容易になる。また、複数のプロパティを組み合わせた値を再利用できる

### kiso.cssを前提とした記述

`kiso.css`を前提にSCSSを書く際の注意点（記述の重複を防ぐ）：

- `box-sizing: border-box`は不要（全要素に既に適用済み）
- `margin-block`のリセットは不要（`h2`〜`h6`、`p`、`ul`、`ol`などは既にリセット済み）。必要な値だけ指定する
- `list-style: none`は不要（`kiso.css`で`list-style-type: ""`がデフォルト）。マーカーが必要な場合のみ`list-style-type`を指定する
- `img`の`display: block`と`width: 100%`は不要（`_reset.scss`で既に設定済み）。必要な場合のみ上書きする
- `button`の`border: none`と`padding: 0`は不要（`_reset.scss`で既にリセット済み）。必要なスタイルだけ指定する
- `h1`の`margin: 0`は不要（`_reset.scss`で既にリセット済み）。必要な値だけ指定する
- 論理プロパティを使用する（`kiso.css`が論理プロパティを使用しているため、一貫性を保つ）
- フォーム要素は必要なスタイルだけ指定する（`kiso.css`で既にリセット済み）
- セマンティクスを考慮する（`list-style: none`は避け、`list-style-type: ""`のデフォルトを利用するか、必要に応じて上書きする）

### レイアウトクラスの使い方

- `.l-inner`はレイアウト用のユーティリティクラスで、中央揃え・最大幅・パディングを提供する
- コンポーネント固有の`__inner`クラス（例: `.p-top-cta__inner`）に、`.l-inner`と同じ機能（`max-width`、`margin-inline: auto`）を重複して定義しない
- コンポーネント固有の`__inner`クラスは、`.l-inner`で提供されない追加のスタイル（例: `position: relative`、疑似要素など）のみを定義する
- PHPファイルでは、`<div class="p-top-***__inner l-inner">`のように、コンポーネント固有の`__inner`クラスと`.l-inner`を併用する
- コンポーネント固有の`__inner`クラスは、スタイル指定が不要な場合でもPHPファイルに残しておき、必要に応じてSCSSで上書き可能にする

### SCSSとPHPのクラス対応

- PHPファイルにあるすべてのクラスは、対応するSCSSファイルに記載する
- 必要なスタイルがない場合でも、スタイルが空の状態でセレクタだけは記載しておく（例: `.p-top-cta__inner {}`）
- これにより、PHPファイルで使用されているクラスがSCSSファイルに存在することが保証され、後からスタイルを追加する際に上書きしやすくなる

## JavaScript

### モジュール構成

- **エントリファイル**: `src/assets/js/main.js` がエントリファイルです
- **機能別モジュール**: 機能別にモジュールを分割して、`main.js` でインポートします

### モジュール命名規則

機能別モジュールは `_` プレフィックスを付与：

- `_header.js`: ヘッダー関連
- `_drawer.js`: ドロワーメニュー
- `_modal.js`: モーダル
- `_accordion.js`: アコーディオン

## 画像の扱い

### CSS内の画像

- `src/assets/images/**` を Sass の `url(...)` 経由で参照することを推奨します
- Viteがビルド時に解決し、ハッシュ付きファイル名に変換されます

### HTML内の画像

- `ty_theme_image_url()` を使用して画像URLを取得することを推奨します
- WordPressのメディアライブラリを使用する場合は `wp_get_attachment_image()` を優先することを推奨します

## その他

### コミットメッセージ

- コミットメッセージを日本語で生成する

### デザインデータ取得

- Figmaからデザインデータが取得できない場合は、コメントだけ残す
- `overview.md`などの指示があっても、Figmaからデータが取得できない場合は実装しない
- 実装予定の機能はコメントで意図を明確にする

### 言語

- 日本語で回答する

## スクリプトの実行方法

実行権限を付与せず、`bash`コマンドで実行する方法を推奨します。

- 理由: クロスプラットフォーム対応、Git管理の簡素化、初回セットアップの削減
- 例: `bash scripts/font-compress.sh input.ttf output.woff2`
- 各スクリプトのREADMEでは`bash`コマンドのみを記載し、実行権限付与の方法は記載しない

## 参考資料

- **設計判断**: [architecture.md](architecture.md) を参照
- **開発ガイド**: [development.md](development.md) を参照
